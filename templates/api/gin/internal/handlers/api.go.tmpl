package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// Item represents a simple resource
type Item struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

// RegisterRoutes registers all API routes
func RegisterRoutes(api *gin.RouterGroup) {
	v1 := api.Group("/v1")
	{
		v1.GET("", welcome)

		items := v1.Group("/items")
		{
			items.GET("", getItems)
			items.POST("", createItem)
			items.GET("/:id", getItem)
			items.PUT("/:id", updateItem)
			items.DELETE("/:id", deleteItem)
		}
	}
}

// Handler functions
func welcome(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "Welcome to the API",
	})
}

func getItems(c *gin.Context) {
	// In a real application, fetch from database
	items := []Item{
		{ID: "1", Name: "Item One"},
		{ID: "2", Name: "Item Two"},
	}
	c.JSON(http.StatusOK, gin.H{"items": items})
}

func createItem(c *gin.Context) {
	var item Item
	if err := c.ShouldBindJSON(&item); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// In a real application, save to database
	item.ID = "3" // simulate ID generation

	c.JSON(http.StatusCreated, gin.H{
		"message": "Item created",
		"item":    item,
	})
}

func getItem(c *gin.Context) {
	id := c.Param("id")
	// In a real application, fetch from database
	item := Item{ID: id, Name: "Sample Item"}
	c.JSON(http.StatusOK, item)
}

func updateItem(c *gin.Context) {
	id := c.Param("id")
	var item Item
	if err := c.ShouldBindJSON(&item); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// In a real application, update in database
	item.ID = id // ensure ID matches the URL parameter

	c.JSON(http.StatusOK, gin.H{
		"message": "Item updated",
		"item":    item,
	})
}

func deleteItem(c *gin.Context) {
	id := c.Param("id")
	// In a real application, delete from database
	c.JSON(http.StatusOK, gin.H{
		"message": "Item deleted",
		"id":      id,
	})
}
